@import _root_.java.nio.file.Path
@import com.omegaup.libinteractive.idl.IDL
@import com.omegaup.libinteractive.target.ExecDescription
@import com.omegaup.libinteractive.target.Target
@(target: Target, message: String, idl: IDL, commands: Iterable[ExecDescription], numProcesses: Int, maxNameLength: Int)
/* @message */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define PSAPI_VERSION 1
#include <windows.h>
#include <psapi.h>

#define NUM_PROCESSES @numProcesses
#define LABEL_FORMAT "[%@(maxNameLength)s] "

const char* interfaces[] = {
	@idl.allInterfaces.map('"' + _.name + '"').mkString(", ")
};

typedef struct {
	const char* out;
	int in_count;
	const char* in[NUM_PROCESSES - 1];
} pipe_description;

pipe_description pipe_descriptions[NUM_PROCESSES] = {
	{ "@target.pipeFilename(idl.main, idl.main)", NUM_PROCESSES - 1, { @idl.interfaces.map('"' + target.pipeFilename(idl.main, _) + '"').mkString(", ") } },
@for(interface <- idl.interfaces) {
	{ "@target.pipeFilename(interface, interface)", 1, { @List('"' + target.pipeFilename(interface, idl.main) + '"').padTo(numProcesses - 1, "NULL").mkString(", ") } }
}
};

char* const commands[] = {
@for(command <- commands) {
	"@command.args.map("\\\"" + _.replace("/", "\\").replace("\\", "\\\\") + "\\\"").mkString(" ")",
}
};
int has_stdin[NUM_PROCESSES] = {
	1, @idl.interfaces.map(interface => "0").mkString(", ")
};

typedef struct {
	OVERLAPPED overlapped;
	HANDLE read_fd;
	HANDLE write_fd;
	const char* read_name;
	const char* write_name;
	int connected;
	int closed;
	int pending;
	int pos;
	char buf[1024];
	int line;
	int main_stdout;
	const char* prefix;
} buffer;

typedef struct {
	PROCESS_INFORMATION pi;
	HANDLE out;
	HANDLE err;
} process;

buffer buffers[2 * NUM_PROCESSES + 2 * (NUM_PROCESSES - 1)];
HANDLE events[2 * NUM_PROCESSES + 2 * (NUM_PROCESSES - 1)];
process processes[NUM_PROCESSES];

// Similar in spirit to perror.
static void print_error(const char* message, DWORD error) {
	char buffer[1024];
	FormatMessageA(
		FORMAT_MESSAGE_FROM_SYSTEM |
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		error,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		buffer,
		sizeof(buffer),
		NULL);
	fprintf(stderr, "%s: %s\n", message, buffer);
}

// Ensure a buffer is fully written into the fd.
static void write_full(HANDLE fd, const char* buffer, DWORD bytes_read) {
	BOOL success;
	DWORD bytes_written;
	while (bytes_read) {
		success = WriteFile(
			fd,
			buffer,
			bytes_read,
			&bytes_written,
			NULL
		);
		if (!success || bytes_written == 0) {
			print_error("WriteFile", GetLastError());
			exit(1);
		}
		bytes_read -= bytes_written;
		buffer += bytes_written;
	}
}

// Once a buffer is read, send it out to its corresponding handle.
// Main's stdout will be highlighted in white instead of gray (unless
// redirected to a pipe or file). All other stdout/stderr will go to
// stderr and will have a nice label.
static void process_buffer(buffer* buf) {
	if (buf->line) {
		char label[1024];
		_snprintf(label, sizeof(label), LABEL_FORMAT, buf->prefix);
		size_t label_len = strlen(label);
		const char* last = buf->buf;
		const char* end = buf->buf + buf->pos;
		int should_label = GetFileType(buf->write_fd) == FILE_TYPE_CHAR;
		int should_color = buf->main_stdout;
		CONSOLE_SCREEN_BUFFER_INFO color_info;
		if (should_color) {
			GetConsoleScreenBufferInfo(buf->write_fd, &color_info);
		}
		for (const char* pos = buf->buf; pos < end; pos++) {
			if (*pos == '\n') {
				if (should_label) {
					if (should_color) {
						SetConsoleTextAttribute(
							buf->write_fd,
							FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE
						);
					}
					write_full(buf->write_fd, label, label_len);
					if (should_color) {
						SetConsoleTextAttribute(
							buf->write_fd,
							color_info.wAttributes
						);
					}
				}
				write_full(buf->write_fd, last, pos - last + 1);
				last = pos + 1;
			}
		}
		if (last == buf->buf) {
			// Nothing written, force flush
			if (should_label) {
				write_full(buf->write_fd, label, label_len);
			}
			write_full(buf->write_fd, buf->buf, buf->pos);
			write_full(buf->write_fd, "\r\n", 2);
			buf->pos = 0;
		} else {
			char* wpos = buf->buf;
			for (const char* rpos = last; rpos < end; rpos++, wpos++) {
				*wpos++ = *rpos;
			}
			buf->pos = end - last;
		}
	} else {
		write_full(buf->write_fd, buf->buf, buf->pos);
		buf->pos = 0;
	}
}

// A wrapper for CreateProcess. Also redirects stdio.
void execute(int i) {
	STARTUPINFOA si;

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
	si.hStdInput = has_stdin[i] ? GetStdHandle(STD_INPUT_HANDLE): INVALID_HANDLE_VALUE;
	si.hStdOutput = processes[i].out;
	si.hStdError = processes[i].err;
	si.dwFlags = STARTF_USESTDHANDLES;
	
	BOOL success = CreateProcessA(
		NULL,
		commands[i],
		NULL,
		NULL,
		TRUE,
		0,
		NULL,
		NULL,
		&si,
		&processes[i].pi
	);
	if (!success) {
		print_error("CreateProcess", GetLastError());
		exit(1);
	}
}

// Similar to mknod for a pipe.
static HANDLE create_pipe(const char* name, int read) {
	HANDLE named_pipe = CreateNamedPipeA(
		name,
		read ?
			(PIPE_ACCESS_INBOUND | FILE_FLAG_OVERLAPPED) :
			PIPE_ACCESS_OUTBOUND,
		PIPE_TYPE_BYTE | PIPE_WAIT,
		PIPE_UNLIMITED_INSTANCES,
		1024,
		1024,
		0,
		NULL
	);
	if (named_pipe == INVALID_HANDLE_VALUE) {
		print_error("CreateNamedPipe", GetLastError());
		exit(1);
	}
	return named_pipe;
}

// This function should be similar to CreatePipe, but allowing one
// end (the reading end) of the pipe to have overlapped I/O.
static unsigned long long pipe_counter = 0;
static void create_pipe_pair(HANDLE* read, HANDLE* write) {
	char pipe_name_buffer[1024];
	_snprintf(pipe_name_buffer, sizeof(pipe_name_buffer),
	          "\\\\.\\pipe\\libinteractive_%I64u", pipe_counter++);
	SECURITY_ATTRIBUTES sa;
	ZeroMemory(&sa, sizeof(sa));
	sa.nLength = sizeof(sa);
	sa.bInheritHandle = TRUE;
	
	*read = CreateNamedPipeA(
		pipe_name_buffer,
		PIPE_ACCESS_INBOUND | FILE_FLAG_OVERLAPPED,
		PIPE_TYPE_BYTE | PIPE_WAIT,
		1,
		1024,
		1024,
		0,
		&sa
	);
	
	if (!*read || !SetHandleInformation(*read, HANDLE_FLAG_INHERIT, 0)) {
		print_error("CreateNamedPipe", GetLastError());
		exit(1);
	}
	
	*write = CreateFileA(
		pipe_name_buffer,
		GENERIC_WRITE,
		0,
		&sa,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL
	);
	
	if (!*write) {
		print_error("CreateFile", GetLastError());
		exit(1);
	}
}

int main(int argc, char* argv[]) {
	long maxrss = 0;
	long long utime = 0;

	int retval = 0;
	memset(buffers, 0, sizeof(buffers));
	size_t num_buffers = 0;

	// Create stdout/stderr pipes.
	memset(buffers, 0, sizeof(buffers));	
	for (int i = 0; i < NUM_PROCESSES; i++) {
		create_pipe_pair(&buffers[num_buffers].read_fd, &processes[i].out);
		BOOL success = DuplicateHandle(
			GetCurrentProcess(),
			i ?
				GetStdHandle(STD_ERROR_HANDLE) :
				GetStdHandle(STD_OUTPUT_HANDLE),
			GetCurrentProcess(),
			&buffers[num_buffers].write_fd,
			0,
			FALSE,
			DUPLICATE_SAME_ACCESS
		);
		buffers[num_buffers].read_name = interfaces[i];
		buffers[num_buffers].write_name = i ? "stderr" : "stdout";
		if (!success) {
			print_error("DuplicateHandle", GetLastError());
			exit(1);
		}
		buffers[num_buffers].line = 1;
		buffers[num_buffers].main_stdout = i == 0;
		buffers[num_buffers].prefix = interfaces[i];
		events[num_buffers] = CreateEvent(
			NULL,
			TRUE,
			TRUE,
			NULL
		);
		buffers[num_buffers].overlapped.hEvent = events[num_buffers];
		num_buffers++;
		
		create_pipe_pair(&buffers[num_buffers].read_fd, &processes[i].err);
		success = DuplicateHandle(
			GetCurrentProcess(),
			GetStdHandle(STD_ERROR_HANDLE),
			GetCurrentProcess(),
			&buffers[num_buffers].write_fd,
			0,
			FALSE,
			DUPLICATE_SAME_ACCESS
		);
		if (!success) {
			print_error("DuplicateHandle", GetLastError());
			exit(1);
		}
		buffers[num_buffers].read_name = interfaces[i];
		buffers[num_buffers].write_name = "stderr";
		buffers[num_buffers].line = 1;
		buffers[num_buffers].prefix = interfaces[i];
		events[num_buffers] = CreateEvent(
			NULL,
			TRUE,
			TRUE,
			NULL
		);
		buffers[num_buffers].overlapped.hEvent = events[num_buffers];
		num_buffers++;
	}

	// Create RPC pipes.
	for (int i = 0; i < NUM_PROCESSES; i++) {
		HANDLE out = create_pipe(pipe_descriptions[i].out, 0);
		for (int j = 0; j < pipe_descriptions[i].in_count; j++) {
			events[num_buffers] = CreateEvent(
				NULL,
				TRUE,
				TRUE,
				NULL
			);
			buffers[num_buffers].overlapped.hEvent = events[num_buffers];
			buffers[num_buffers].read_name = pipe_descriptions[i].out;
			buffers[num_buffers].write_name = pipe_descriptions[i].in[j];
			buffers[num_buffers].read_fd =
				create_pipe(pipe_descriptions[i].in[j], 1);
			if (j == 0) {
				buffers[num_buffers].write_fd = out;
			} else {
				BOOL success = DuplicateHandle(
					GetCurrentProcess(),
					out,
					GetCurrentProcess(),
					&buffers[num_buffers].write_fd,
					0,
					FALSE,
					DUPLICATE_SAME_ACCESS
				);
				
				if (!success) {
					print_error("DuplicateHandle", GetLastError());
					exit(1);
				}
			}
			if (ConnectNamedPipe(buffers[num_buffers].read_fd,
			                     &buffers[num_buffers].overlapped)) {
				print_error("ConnectNamedPipe", GetLastError());
				exit(1);
			}
			switch (GetLastError()) {
				case ERROR_IO_PENDING:
					buffers[num_buffers].connected = 0;
					break;
				case ERROR_PIPE_CONNECTED:
					buffers[num_buffers].connected = 1;
					break;
				default:
					print_error("ConnectNamedPipe", GetLastError());
					exit(1);
			}
			
			num_buffers++;
		}
	}

	// Execute the children.
	for (int i = 0; i < NUM_PROCESSES; i++) {
		execute(i);
	}

	// Wait for the children to connect their ends of the pipes.
	for (int i = 2 * NUM_PROCESSES; i < num_buffers; i++) {
		DWORD _;
		BOOL success = GetOverlappedResult(
			buffers[i].read_fd,
			&buffers[i].overlapped,
			&_,
			TRUE
		);
		if (!success) {
			print_error("GetOverlappedResult", GetLastError());
			exit(1);
		}
	}
	
	// Release our copies of the children's ends of the pipes.
	for (int i = 0; i < NUM_PROCESSES; i++) {
		CloseHandle(processes[i].out);
		CloseHandle(processes[i].err);
	}
	
	// Process I/O on all the pipes until they are all closed.
	int alive = num_buffers;
	while (alive) {
		int i = WaitForMultipleObjects(
			num_buffers,
			events,
			FALSE,
			INFINITE
		) - WAIT_OBJECT_0;
		
		if (i < 0 || i > (num_buffers - 1)) {
			print_error("WaitForMultipleObjects", GetLastError());
			exit(1);
		}
		
		if (buffers[i].closed) {
			continue;
		}
		
		BOOL success;
		DWORD bytes_read;
		if (buffers[i].pending) {
			success = GetOverlappedResult(
				buffers[i].read_fd,
				&buffers[i].overlapped,
				&bytes_read,
				FALSE
			);
			buffers[i].pending = 0;
			if (!success && bytes_read <= 0) {
				buffers[i].closed = 1;
				CloseHandle(buffers[i].read_fd);
				CloseHandle(buffers[i].write_fd);
				ResetEvent(events[i]);
				alive--;
				continue;
			}
			buffers[i].pos += bytes_read;
			process_buffer(&buffers[i]);
		}
		
		while (1) {
			success = ReadFile(
				buffers[i].read_fd,
				buffers[i].buf + buffers[i].pos,
				sizeof(buffers[i].buf) - buffers[i].pos,
				&bytes_read,
				&buffers[i].overlapped
			);
			
			if (success && bytes_read > 0) {
				buffers[i].pending = 0;
				buffers[i].pos += bytes_read;
				process_buffer(&buffers[i]);
				continue;
			}
			
			DWORD last_error = GetLastError();
			if (!success && last_error == ERROR_IO_PENDING) {
				buffers[i].pending = 1;
				break;
			}
			
			buffers[i].closed = 1;
			CloseHandle(buffers[i].read_fd);
			CloseHandle(buffers[i].write_fd);
			ResetEvent(events[i]);
			alive--;
			break;
		}
	}

	// Close all processes and grab execution data.
	for (int i = 0; i < NUM_PROCESSES; i++) {
		WaitForSingleObject(processes[i].pi.hProcess, INFINITE);
		FILETIME creation, exit, kernel, user;
		GetProcessTimes(
			processes[i].pi.hProcess,
			&creation,
			&exit,
			&kernel,
			&user
		);
		ULARGE_INTEGER usertime;
		usertime.LowPart = user.dwLowDateTime;
		usertime.HighPart = user.dwHighDateTime;
		utime += usertime.QuadPart / 10;
		
		PROCESS_MEMORY_COUNTERS counters;
		ZeroMemory(&counters, sizeof(counters));
		counters.cb = sizeof(counters);
		GetProcessMemoryInfo(
			processes[i].pi.hProcess,
			&counters,
			sizeof(counters)
		);
		maxrss = max(maxrss, counters.PeakWorkingSetSize);
		DWORD exit_code = 1;
		GetExitCodeProcess(
			processes[i].pi.hProcess,
			&exit_code
		);
		retval = max(retval, exit_code);
			
		CloseHandle(processes[i].pi.hProcess);
		CloseHandle(processes[i].pi.hThread);
	}

	fprintf(stderr, "\nMemory: %7.3f MB\n", maxrss / 1048576.0f);
	fprintf(stderr, "Time:   %7.3f s\n", utime / 1e6);
	fclose(stdout);
	fclose(stderr);

	return retval;
}
