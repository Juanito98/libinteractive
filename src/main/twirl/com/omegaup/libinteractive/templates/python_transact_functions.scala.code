@(verbose: Boolean)
#!/usr/bin/python
# Auto-generated by libinteractive. Do not edit.

import mmap
import os
import struct
import sys

_MESSAGE_SIZE = 64

class _Message:
	def __init__(self, msgid, block_offset, fd):
		self.fd = fd
		self.block_offset = block_offset
		self.offset = (1 + self.block_offset) * _MESSAGE_SIZE
		self.msgid = msgid
		self.fd.seek(self.offset + 32)
	
	def read(self, size):
		return self.fd.read(size)

	def write(self, buf):
		return self.fd.write(buf)

	def release(self):
		self.fd[self.offset+16:self.offset+24] = struct.pack('q', 1)

class _Transact:
	def __init__(self, name, transact_name, shm_name, shm_size, parent):
@if(verbose) {
		print >> sys.stderr, "Opening `%s'" % name
}
		self.__name = name
		self.__size = shm_size / _MESSAGE_SIZE
		self.__transact = open(transact_name, 'r+b')

		# Make sure the child process waits until the parent issues a read() call.
		self.__transact.write(struct.pack('Q', parent))
		self.__transact.flush()

		self.__shmfile = open(shm_name, 'r+b')
		if parent:
			os.ftruncate(self.__shmfile.fileno(), shm_size)
		self.__shm = mmap.mmap(self.__shmfile.fileno(), shm_size)
		if parent:
			self.__shm[0:32] = struct.pack('qqqq', 0, 0, -1, -1)

	def allocate(self, size, msgid): 
		self.__shm.seek(0)
		size += 32 # For the page header.
		size += (~(size - 1) & 0x3F) # Align to blocks.
		blocks = size / _MESSAGE_SIZE

		if blocks == 1:
			head = struct.unpack('q', self.__shm[16:24])[0] # small_message_list
		else:
			head = struct.unpack('q', self.__shm[24:32])[0] # large_message_list
		next_block = head
		prev_next = self.__size + 1

		# Try to reuse an old allocation.
		while next_block != -1:
			# The messages form a linked list that goes backwards. If any next pointer
			# lies outside of the legal values, or it does not appear before in the
			# shared memory region, it is definitely invalid.
			if next_block < 0 or next_block >= self.__size or next_block >= prev_next:
				raise IOError("Illegal next pointer")
			offset = (next_block+1) * _MESSAGE_SIZE
			prev__next, prev__size, prev__free = struct.unpack('qqq',
					self.__shm[offset:offset+24])
			if prev__free and prev__size == blocks:
				self.__shm[offset+16:offset+24] = struct.pack('q', 0)
				return _Message(msgid, next_block, self.__shm)
			prev_next = next_block
			next_block = prev__next

		# Sanity check.
		free_offset = struct.unpack('q', self.__shm[8:16])[0]
		if free_offset < 0 or free_offset >= self.__size:
			raise IOError("Illegal free offset")

		# Need to perform allocation.
		if self.__size < free_offset + blocks:
			# No more memory.
			raise IOError("No more memory for arena allocation. Need shm size to "
					"be at least %u\n" % ((free_offset + blocks + 1) * _MESSAGE_SIZE))

		offset = (free_offset + 1) * _MESSAGE_SIZE
		self.__shm[offset:offset + 32] = struct.pack('qqqq', head, blocks, 0, msgid)
		if blocks == 1:
			self.__shm[16:24] = struct.pack('q', free_offset) # small_message_list
		else:
			self.__shm[24:32] = struct.pack('q', free_offset) # large_message_list
		self.__shm[8:16] = struct.pack('q', free_offset + blocks) # free_offset

		return _Message(msgid, free_offset, self.__shm)

	def get(self):
		self.__shm.seek(0)
		block_offset = struct.unpack('q', self.__shm[0:8])[0] # current_msg_offset
		if block_offset < 0 or block_offset >= self.__size:
			raise IOError("Illegal message offset")
		offset = (block_offset + 1) * _MESSAGE_SIZE
		msgid = struct.unpack('q', self.__shm[offset+24:offset+32])[0]
		return _Message(msgid, block_offset, self.__shm)

	def call(self, message, noreturn, nofree):
		self.__shm.seek(0)
		self.__shm[0:8] = struct.pack('q', message.block_offset) # current_msg_offset
		if len(self.__transact.read(8)) != 8:
			if noreturn:
				sys.exit(0)
			else:
				raise IOError("Confused about exiting")
		if not nofree:
			message.release()
		return self.get()
