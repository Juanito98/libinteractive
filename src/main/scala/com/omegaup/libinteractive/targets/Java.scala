package com.omegaup.libinteractive.target

import java.nio.file.Paths

import scala.collection.mutable.StringBuilder

import com.omegaup.libinteractive.idl._

class Java(idl: IDL, options: Options, parent: Boolean) extends Target(idl, options) {
	override def generate() = {
		if (parent) {
			val mainFile = s"${idl.main.name}.java"
			List(
				new OutputDirectory(Paths.get(idl.main.name)),
				new OutputLink(Paths.get(idl.main.name, mainFile), Paths.get(mainFile)),
				generateMainHeader,
				generateMainFile)
		} else {
			val moduleFile = s"${options.moduleName}.java"
			idl.interfaces.flatMap(interface =>
				List(
					new OutputDirectory(Paths.get(interface.name)),
					new OutputLink(Paths.get(interface.name, moduleFile), Paths.get(moduleFile)),
					generateHeader(interface),
					generate(interface))
			)
		}
	}

	override def generateMakefileRules() = {
		if (parent) {
			List(MakefileRule(Paths.get(idl.main.name, idl.main.name),
				List(
					Paths.get(idl.main.name, s"${idl.main.name}.java"),
					Paths.get(idl.main.name, s"${idl.main.name}_entry.java")),
				"/usr/bin/javac $^"))
		} else {
			idl.interfaces.flatMap(interface =>
				List(
					MakefileRule(Paths.get(interface.name, s"${interface.name}.class"),
						List(
							Paths.get(interface.name, s"${interface.name}.java")),
						s"/usr/bin/javac $$^"),
					MakefileRule(Paths.get(interface.name, s"${interface.name}_entry.class"),
						List(
							Paths.get(interface.name, s"${interface.name}_entry.java")),
						s"/usr/bin/javac $$^")
				)
			)
		}
	}

	override def generateRunCommands() = {
		(if (parent) {
			List(idl.main)
		} else {
			idl.interfaces
		}).map(interface =>
			Array("/usr/bin/java", "-cp",
				options.outputDirectory.resolve(interface.name).toString,
				s"${interface.name}_entry")
		)
	}

	private def arrayDim(e: Expression) = s"[${e.value}]"

	private def formatPrimitive(t: PrimitiveType) = {
		t.name match {
			case "long" => "long long"
			case primitive: String => primitive
		}
	}

	private def formatType(t: Type) = {
		t match {
			case arrayType: ArrayType =>
				s"${formatPrimitive(arrayType.primitive)}(*)" +
					arrayType.lengths.tail.map(arrayDim).mkString
			case primitiveType: PrimitiveType =>
				s"${formatPrimitive(primitiveType)}"
		}
	}

	private def formatParam(param: Parameter) = {
		param.paramType match {
			case arrayType: ArrayType =>
				s"${formatPrimitive(arrayType.primitive)} ${param.name}[]" +
					arrayType.lengths.tail.map(arrayDim).mkString
			case primitiveType: PrimitiveType =>
				s"${formatPrimitive(primitiveType)} ${param.name}"
		}
	}

	private def fieldLength(fieldType: Type) = {
		fieldType match {
			case primitiveType: PrimitiveType =>
				s"sizeof(${primitiveType.name})"
			case arrayType: ArrayType =>
				s"sizeof(${arrayType.primitive.name}) * " +
					arrayType.lengths.map(_.value).mkString(" * ")
		}
	}

	private def declareFunction(function: Function) = {
		s"${formatPrimitive(function.returnType)} ${function.name}(" +
			function.params.map(formatParam).mkString(", ") + ")"
	}

	private def declareVar(param: Parameter) = {
		param.paramType match {
			case array: ArrayType =>
				s"${formatPrimitive(array.primitive)} (*${param.name})" +
					array.lengths.tail.map(arrayDim).mkString
			case primitive: PrimitiveType =>
				s"${formatPrimitive(primitive)} ${param.name}"
		}
	}

	private def generateHeader(interface: Interface) = {
		val builder = new StringBuilder
		builder ++= "/* Auto-generated by libinteractive */\n\n"
		interface.functions.map(declareFunction(_) + ";\n").foreach(builder ++= _)
		idl.main.functions.map(declareFunction(_) + ";\n").foreach(builder ++= _)
		OutputFile(
			Paths.get(interface.name, s"${options.moduleName}.h"),
			builder.mkString)
	}

	private def generate(interface: Interface) = {
		val builder = new StringBuilder
		builder ++= s"""/* Auto-generated by libinteractive */

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.EOFException;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FilterInputStream;
import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

class OmegaUpDataInputStream extends FilterInputStream {
	public OmegaUpDataInputStream(String path) throws FileNotFoundException {
		super(new BufferedInputStream(new FileInputStream(path)));
	}

	public int readInt() throws IOException {
		int b1, b2, b3, b4;
		b1 = in.read();
		b2 = in.read();
		b3 = in.read();
		b4 = in.read();
		if (b4 == -1) {
			throw new EOFException();
		}
		return (b4 << 24) | (b3 << 16) | (b2 << 8) | b1;
	}
}

class OmegaUpDataOutputStream extends FilterOutputStream {
	public OmegaUpDataOutputStream(String path) throws FileNotFoundException {
		super(new BufferedOutputStream(new FileOutputStream(path)));
	}

	public void writeInt(int x) throws IOException {
		out.write((x >>> 0) & 0xFF);
		out.write((x >>> 8) & 0xFF);
		out.write((x >>> 16) & 0xFF);
		out.write((x >>> 24) & 0xFF);
	}
}

public class ${interface.name}_entry {
	static OmegaUpDataInputStream __in = null;
	static OmegaUpDataOutputStream __out = null;

${generateMessageLoop(List((idl.main, interface, "__out")), "__in")}

	public static void main(String[] args) throws IOException {
		${if (options.verbose) {
			"System.err.printf(\"\\t[" + interface.name + "] opening `" + pipeFilename(interface) + "'\\n\");\n"
		} else ""}
		try (OmegaUpDataInputStream fin = new OmegaUpDataInputStream("${pipeFilename(interface)}")) {
			${if (options.verbose) {
				"System.err.printf(\"\\t[" + interface.name + "] opening `" + pipeFilename(idl.main) + "'\\n\");\n"
			} else ""}
			try (OmegaUpDataOutputStream fout = new OmegaUpDataOutputStream("${pipeFilename(idl.main)}")) {
				__in = fin;
				__out = fout;
				__message_loop(-1);
			}
		}
	}
"""
		for (function <- idl.main.functions) {
			builder ++= generateShim(function, idl.main, interface, "__out", "__in", false)
		}

		builder ++= "}\n"

		OutputFile(
			Paths.get(interface.name, s"${interface.name}_entry.java"),
			builder.mkString)
	}

	private def generateMainHeader() = {
		val builder = new StringBuilder
		builder ++= "/* Auto-generated by libinteractive */\n\n"
		idl.allInterfaces.flatMap(interface => {
			interface.functions.map(declareFunction(_) + ";\n")
		}).foreach(builder ++= _)
		OutputFile(
			Paths.get(idl.main.name, s"${options.moduleName}.h"),
			builder.mkString)
	}

	private def generateMainFile() = {
		val openPipes = idl.interfaces.map(interface => {
			(if (options.verbose) {
				s"""\tSystem.err.printf("\\t[${idl.main.name}] opening `${pipeFilename(interface)}'\\n");\n"""
			} else {
				""
			}) +
s"""\tif ((${pipeName(interface)} = open("${pipeFilename(interface)}", O_WRONLY)) == -1) {
		perror("open");
		exit(1);
	}\n"""}).mkString("\n") +
			(if (options.verbose) {
				s"""\tSystem.err.printf("\\t[${idl.main.name}] opening `${pipeFilename(idl.main)}'\\n");\n"""
			} else {
				""
			}) +
s"""\tif ((${pipeName(idl.main)} = open("${pipeFilename(idl.main)}", O_RDONLY)) == -1) {
		perror("open");
		exit(1);
	}\n"""
		val closePipes = (idl.interfaces ++ List(idl.main)).map(interface => {
			(if (options.verbose) {
				s"""\tSystem.err.printf("\\t[${idl.main.name}] closing `${pipeFilename(interface)}'\\n");\n"""
			} else {
				""
			}) +
s"""\tif (${pipeName(interface)} != -1) {
		if (close(${pipeName(interface)}) == -1) {
			perror("close");
		}
	}"""}).mkString("\n")
		val builder = new StringBuilder
		builder ++= s"""/* Auto-generated by libinteractive */
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include "${options.moduleName}.h"

#ifdef __cplusplus
extern "C" {
#endif

// declared in crt1.o
void _start();

void __entry();
static void __exit();
static long long __elapsed_time = 0;
static int ${idl.allInterfaces.map(pipeName).mkString(", ")};

#ifdef __cplusplus
}
#endif

void __entry() {
$openPipes

	// Register __exit to be called when main returns.
	atexit(__exit);
	// Perform regular libc startup
	_start();
}

void __exit() {
$closePipes
}

"""
		builder ++= generateMessageLoop(
			idl.interfaces.map{
				interface => (interface, idl.main, pipeName(interface))
			},
			pipeName(idl.main)
		)
		idl.interfaces.foreach(interface => {
			interface.functions.foreach(
				builder ++= generateShim(_, interface, idl.main, pipeName(interface),
					pipeName(idl.main), true)
			)
		})
		
		OutputFile(
			Paths.get(idl.main.name, s"${idl.main.name}_entry.java"),
			builder.mkString)
	}

	private def generateMessageLoop(interfaces: List[(Interface, Interface, String)], infd: String) = {
		val builder = new StringBuilder
		builder ++= s"""	static void __message_loop(int current_function) throws IOException {
		int msgid;
		while (true) {
			try {
				msgid = $infd.readInt();
			} catch (EOFException e) {
				break;
			}
			if (msgid == current_function) return;
			switch (msgid) {\n"""
		for ((caller, callee, outfd) <- interfaces) {
			for (function <- callee.functions) {
				builder ++= f"\t\t\t\tcase 0x${functionIds((caller.name, callee.name, function.name))}%x: {\n"
				builder ++= s"\t\t\t\t\t// ${caller.name} -> ${callee.name}.${function.name}\n"
				if (options.verbose) {
					builder ++=
						s"""\t\t\t\t\tSystem.err.printf("\\t[${callee.name}] calling ${function.name} begin\\n");\n"""
				}
				for (param <- function.params) {
					builder ++= (param.paramType match {
						case array: ArrayType => {
							s"\t\t\t\t\t${declareVar(param)} = (${formatType(array)})" +
							s"malloc(${fieldLength(array)});\n" +
							s"\t\t\t\t\tread($infd, ${param.name}, ${fieldLength(array)});\n"
						}
						case primitive: PrimitiveType => {
							s"\t\t\t\t\t${declareVar(param)} = $infd.readInt();\n"
						}
					})
				}
				builder ++= s"\t\t\t\t\tint cookie = $infd.readInt();\n"
				builder ++= (if (function.returnType == PrimitiveType("void")) {
					"\t\t\t\t\t"
				} else {
					s"\t\t\t\t\t${formatType(function.returnType)} result = "
				})
				builder ++=
					s"""${options.moduleName}.${function.name}(${function.params.map(_.name).mkString(", ")});\n"""
				builder ++= s"\t\t\t\t\t$outfd.writeInt(msgid);\n"
				if (function.returnType != PrimitiveType("void")) {
					builder ++= s"\t\t\t\t\t$outfd.writeInt(result);\n"
				}
				builder ++= s"\t\t\t\t\t$outfd.writeInt(cookie);\n"
				builder ++= s"\t\t\t\t\t$outfd.flush();\n"
				if (options.verbose) {
					builder ++=
						s"""\t\t\t\t\tSystem.err.printf("\\t[${callee.name}] calling ${function.name} end\\n");\n"""
				}
				builder ++= "\t\t\t\t\tbreak;\n"
				builder ++= "\t\t\t\t}\n"
			}
		}
		builder ++= """				default: {
					System.err.printf("Unknown message id 0x%x\\n", msgid);
					System.exit(1);
				}
			}
		}
		if (current_function != -1) {
			System.err.printf("Confused about exiting\\n");
			System.exit(1);
		}
	}
"""
		builder
	}

	private def generateShim(function: Function, callee: Interface, caller: Interface,
			outfd: String, infd: String, generateTiming: Boolean) = {
		val builder = new StringBuilder
		builder ++= declareFunction(function)
		builder ++= " {\n"
		if (options.verbose) {
			builder ++=
				s"""\tSystem.err.printf("\\t[${caller.name}] invoking ${function.name} begin\\n");\n"""
		}
		builder ++= "\tconst int msgid = "
		builder ++= f"0x${functionIds((caller.name, callee.name, function.name))}%x;\n"
		builder ++= s"\twrite($outfd, &msgid, sizeof(int));\n"
		function.params.foreach(param => {
			builder ++= (param.paramType match {
				case _: PrimitiveType =>
					s"\twrite($outfd, &${param.name}, ${fieldLength(param.paramType)});\n"
				case _: ArrayType =>
					s"\twrite($outfd, ${param.name}, ${fieldLength(param.paramType)});\n"
			})
		})
		if (generateTiming) {
			builder ++=
				"\tstruct timespec t0, t1;\n\tclock_gettime(CLOCK_MONOTONIC, &t0);\n"
		}
		builder ++= f"\tint cookie = 0x${rand.nextInt}%x;\n"
		builder ++= s"\twrite($outfd, &cookie, sizeof(cookie));\n"
		builder ++= "\t__message_loop(msgid);\n"
		if (function.returnType != PrimitiveType("void")) {
			builder ++= s"\t${formatType(function.returnType)} ans = 0;\n"
			builder ++= s"\tread($infd, &ans, sizeof(ans));\n"
		}
		builder ++= "\tint cookie_result = 0;\n"
		builder ++= s"\tread($infd, &cookie_result, sizeof(int));\n"
		if (generateTiming) {
			builder ++= "\tclock_gettime(CLOCK_MONOTONIC, &t1);\n"
			builder ++= "\t__elapsed_time += (t1.tv_sec * 1000000 + t1.tv_nsec / 1000) - " +
				"(t0.tv_sec * 1000000 + t0.tv_nsec / 1000);\n"
		}

		builder ++= "\tif (cookie != cookie_result) {\n"
		builder ++= "\t\tSystem.err.printf(\"invalid cookie\\n\");\n"
		builder ++= "\t\texit(1);\n"
		builder ++= "\t}\n"

		if (options.verbose) {
			builder ++=
				s"""\tSystem.err.printf("\\t[${caller.name}] invoking ${function.name} end\\n");\n"""
		}

		if (function.returnType != PrimitiveType("void")) {
			builder ++= "\treturn ans;\n"
		}
		builder ++= "}\n"

		builder
	}
}

/* vim: set noexpandtab: */
