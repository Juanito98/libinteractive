package com.omegaup.libinteractive.target

import java.nio.file.Paths

import scala.collection.mutable.StringBuilder

import com.omegaup.libinteractive.idl._

class Pascal(idl: IDL, options: Options, parent: Boolean) extends Target(idl, options) {
	override def generate() = {
		if (parent) {
			throw new UnsupportedOperationException;
		} else {
			val moduleFile = s"${options.moduleName}.pas"
			idl.interfaces.flatMap(interface =>
				List(
					new OutputDirectory(Paths.get(interface.name)),
					new OutputLink(Paths.get(interface.name, moduleFile), Paths.get(moduleFile)),
					generateEntry(interface),
					generate(interface))
			)
		}
	}

	override def generateMakefileRules() = {
		if (parent) {
			throw new UnsupportedOperationException;
		} else {
			idl.interfaces.map(interface =>
				MakefileRule(Paths.get(interface.name, interface.name),
					List(
						Paths.get(interface.name, s"${interface.name}.pas"),
						Paths.get(interface.name, s"${idl.main.name}.pas"),
						Paths.get(interface.name, s"${interface.name}_entry.pas")),
					"/usr/bin/fpc -Tlinux -O2 -Mobjfpc -Sc -Sh -o$@ $^"))
		}
	}

	override def generateRunCommands() = {
		(if (parent) {
			throw new UnsupportedOperationException;
		} else {
			idl.interfaces
		}).map(interface =>
			ExecDescription(Array(options.outputDirectory
				.resolve(Paths.get(interface.name, interface.name))
				.toString))
		)
	}

	private def formatExpression(e: Expression, prefix: String) = {
		e match {
			case int: IntExpression => {
				int.value
			}
			case variable: VariableExpression => {
				prefix + variable.value
			}
		}
	}

	private def arrayDim(e: Expression, prefix: String) = {
		s"[${formatExpression(e, prefix)}]"
	}

	private def formatPrimitive(t: PrimitiveType) = {
		t.name match {
			case "long" => "Int64"
			case "int" => "LongInt"
			case "float" => "Single"
			case "double" => "Double"
			case "char" => "Char"
			case "byte" => "Byte"
		}
	}

	private def formatType(t: Type) = {
		t match {
			case arrayType: ArrayType =>
				arrayType.lengths.map(_ => "array of ").mkString +
					s"${formatPrimitive(arrayType.primitive)}"
			case primitiveType: PrimitiveType =>
				s"${formatPrimitive(primitiveType)}"
		}
	}

	private def formatParam(param: Parameter) = {
		s"${param.name}: ${formatType(param.paramType)}"
	}

	private def fieldLength(fieldType: Type, prefix: String = "") = {
		fieldType match {
			case primitiveType: PrimitiveType =>
				s"sizeof(${formatPrimitive(primitiveType)})"
			case arrayType: ArrayType =>
				s"sizeof(${formatPrimitive(arrayType.primitive)}) * " +
					arrayType.lengths.map(formatExpression(_, prefix)).mkString(" * ")
		}
	}

	private def declareFunction(function: Function) = {
		(if (function.returnType == PrimitiveType("void")) {
			"procedure"
		} else {
			"function"
		}) +
		s" ${function.name}(" +
			function.params.map(formatParam).mkString("; ") + ")" +
		(if (function.returnType == PrimitiveType("void")) {
			""
		} else {
			s": ${formatPrimitive(function.returnType)}"
		}) + ";"
	}

	private def generateEntry(interface: Interface) = {
		val builder = new StringBuilder
		builder ++= s"""{ Auto-generated by libinteractive }

program ${interface.name};

uses Main;

begin
  __entry();
end.
"""
		OutputFile(
			Paths.get(interface.name, s"${interface.name}_entry.pas"),
			builder.mkString)
	}

	private def generate(interface: Interface) = {
		val builder = new StringBuilder
		builder ++= s"""{ Auto-generated by libinteractive }

unit ${idl.main.name};

interface
	procedure __entry();
${
	idl.main.functions.map("\t" + declareFunction(_))
			.mkString("\n")
}
implementation

uses
  ${interface.name}, Classes, SysUtils;

var
	__in: TFileStream;
	__out: TFileStream;

${generateMessageLoop(List((idl.main, interface, "__out")), "__in")}

procedure __entry();
begin
	${if (options.verbose) {
		"\tWriteln(ErrOutput, #9'[" + interface.name + "] opening `" + pipeFilename(interface) + "''');\n"
	} else ""}
	__in := TFileStream.Create('${pipeFilename(interface)}', fmOpenRead);
	${if (options.verbose) {
		"\tWriteln(ErrOutput, #9'" + interface.name + "] opening `" + pipeFilename(idl.main) + "''');\n"
	} else ""}
	__out := TFileStream.Create('${pipeFilename(idl.main)}', fmOpenWrite);
	__message_loop($$FFFFFFFF);
end;

"""
		for (function <- idl.main.functions) {
			builder ++= generateShim(function, idl.main, interface, "__out", "__in")
		}

		builder ++= "end.\n"
		OutputFile(
			Paths.get(interface.name, s"${idl.main.name}.pas"),
			builder.mkString)
	}

	private def generateMessageLoop(interfaces: List[(Interface, Interface, String)], infd: String) = {
		val builder = new StringBuilder
		builder ++= s"""procedure __message_loop(current_function: LongWord);
var
	bytesRead: LongInt;
	msgid: LongWord;
	cookie: LongWord;\n"""
		for ((caller, callee, outfd) <- interfaces) {
			for (function <- callee.functions) {
				if (function.returnType != PrimitiveType("void")) {
					builder ++= s"\t${function.name}___result: ${formatType(function.returnType)};\n"
				}
				for (param <- function.params) {
					builder ++= s"\t${function.name}_${param.name}: ${formatType(param.paramType)};\n"
				}
			}
		}
	builder ++= s"""begin
	while true do
	begin
		bytesRead := $infd.Read(msgid, sizeof(msgid));
		if (bytesRead <> sizeof(msgid)) then
			break;
		if (msgid = current_function) then
			exit;
		case msgid of\n"""
		for ((caller, callee, outfd) <- interfaces) {
			for (function <- callee.functions) {
				builder ++= f"\t\t\t$$${functionIds((caller.name, callee.name, function.name))}%x:\n"
				builder ++= f"\t\t\tbegin\n"
				builder ++= s"\t\t\t\t{ ${caller.name} -> ${callee.name}.${function.name} }\n"
				if (options.verbose) {
					builder ++=
						s"""\t\t\t\tWriteln(ErrOutput, #9'[${callee.name}] calling ${function.name} begin');\n"""
				}
				for (param <- function.params) {
					builder ++= (param.paramType match {
						case array: ArrayType => {
							s"\t\t\t\tSetLength(${function.name}_${param.name}, " +
								array.lengths.map(
									formatExpression(_, s"${function.name}_"))
								.mkString(", ") + ");\n" +
							s"\t\t\t\t$infd.ReadBuffer(${function.name}_${param.name}${array.lengths.map(_ => "[0]").mkString}, " +
								s"""${fieldLength(array, s"${function.name}_")});\n"""
						}
						case primitive: PrimitiveType => {
							s"\t\t\t\t$infd.ReadBuffer(${function.name}_${param.name}, " +
								s"sizeof(${function.name}_${param.name}));\n"
						}
					})
				}
				builder ++= s"\t\t\t\t$infd.ReadBuffer(cookie, sizeof(cookie));\n"
				builder ++= (if (function.returnType == PrimitiveType("void")) {
					"\t\t\t\t"
				} else {
					s"\t\t\t\t${function.name}___result := "
				})
				builder ++=
					s"""${function.name}(${function.params.map(function.name + "_" + _.name).mkString(", ")});\n"""
				builder ++= s"\t\t\t\t$outfd.WriteBuffer(msgid, sizeof(msgid));\n"
				if (function.returnType != PrimitiveType("void")) {
					builder ++= s"\t\t\t\t$outfd.WriteBuffer(${function.name}___result, sizeof(${function.name}___result));\n"
				}
				builder ++= s"\t\t\t\t$outfd.WriteBuffer(cookie, sizeof(cookie));\n"
				if (options.verbose) {
					builder ++=
						s"""\t\t\t\tWriteln(ErrOutput, #9,'[${callee.name}] calling ${function.name} end');\n"""
				}
				builder ++= "\t\t\tend;\n"
			}
		}
		builder ++= """			else begin
				Writeln(ErrOutput, 'Unknown message id 0x', IntToHex(msgid, 8));
				halt(1);
			end;
		end;
	end;
	if (current_function <> $FFFFFFFF) then
	begin
		Writeln(ErrOutput, 'Confused about exiting');
		Halt(1);
	end;
end;
"""
		builder
	}

	private def generateShim(function: Function, callee: Interface, caller: Interface,
			outfd: String, infd: String) = {
		val builder = new StringBuilder
		builder ++= declareFunction(function) + "\n"
		builder ++= "var\n"
		builder ++= "\tmsgid: LongWord;\n"
		builder ++= "\tcookie: LongWord;\n"
		builder ++= "\tcookie_result: LongWord;\n"
		if (function.returnType != PrimitiveType("void")) {
			builder ++= s"\t__result: ${formatType(function.returnType)};\n"
		}
		builder ++= "begin\n"
		if (options.verbose) {
			builder ++=
				s"""\tWriteln(ErrOutput, #9'[${caller.name}] invoking ${function.name} begin');\n"""
		}
		builder ++= "\tmsgid := "
		builder ++= f"$$${functionIds((caller.name, callee.name, function.name))}%x;\n"
		builder ++= s"\t$outfd.WriteBuffer(msgid, sizeof(msgid));\n"
		function.params.foreach(param => {
			builder ++= (param.paramType match {
				case array: ArrayType => {
					s"\t\t\t\t$outfd.WriteBuffer(${param.name}${array.lengths.map(_ => "[0]").mkString}, " +
						s"${fieldLength(array)});\n"
				}
				case primitive: PrimitiveType => {
					s"\t\t\t\t$outfd.WriteBuffer(${param.name}, " +
						s"sizeof(${param.name}));\n"
				}
			})
		})
		builder ++= f"\tcookie := $$${rand.nextInt}%x;\n"
		builder ++= s"\t$outfd.WriteBuffer(cookie, sizeof(cookie));\n"
		builder ++= "\t__message_loop(msgid);\n"
		if (function.returnType != PrimitiveType("void")) {
			builder ++= s"\t$infd.ReadBuffer(__result, sizeof(__result));\n"
		}
		builder ++= s"\t$infd.ReadBuffer(cookie_result, sizeof(cookie_result));\n"

		builder ++= "\tif (cookie <> cookie_result) then\n"
		builder ++= "\tbegin\n"
		builder ++= "\t\tWriteln(ErrOutput, 'invalid cookie');\n"
		builder ++= "\t\tHalt(1);\n"
		builder ++= "\tend;\n"

		if (options.verbose) {
			builder ++=
				s"\tWriteln(ErrOutput, #9'[${caller.name}] invoking ${function.name} end');\n"
		}

		if (function.returnType != PrimitiveType("void")) {
			builder ++= s"\t${function.name} := __result;\n"
		}
		builder ++= "end;\n"

		builder
	}
}

/* vim: set noexpandtab: */
