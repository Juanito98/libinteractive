package com.omegaup.libinteractive.target

import java.nio.file.Paths

import scala.collection.mutable.StringBuilder

import com.omegaup.libinteractive.idl._

class C(idl: IDL, options: Options, parent: Boolean) extends Target(idl, options) {
	override def generate() = {
		if (parent) {
			val mainFile = s"${idl.main.name}.$extension"
			List(
				new OutputDirectory(Paths.get(idl.main.name)),
				new OutputLink(Paths.get(idl.main.name, mainFile), Paths.get(mainFile)),
				generateMainHeader,
				generateMainFile)
		} else {
			val moduleFile = s"${options.moduleName}.$extension"
			idl.interfaces.flatMap(interface =>
				List(
					new OutputDirectory(Paths.get(interface.name)),
					new OutputLink(Paths.get(interface.name, moduleFile), Paths.get(moduleFile)),
					generateHeader(interface),
					generate(interface))
			)
		}
	}

	override def generateMakefileRules() = {
		if (parent) {
			List(MakefileRule(Paths.get(idl.main.name, idl.main.name),
				List(
					Paths.get(idl.main.name, s"${idl.main.name}.$extension"),
					Paths.get(idl.main.name, s"${idl.main.name}_entry.$extension")),
				s"$compiler $cflags -o $$@ -lrt $$^ -O2 -Wl,-e__entry " +
				"-D_XOPEN_SOURCE=600 -Wno-unused-result -Wall"))
		} else {
			idl.interfaces.map(interface =>
				MakefileRule(Paths.get(interface.name, interface.name),
					List(
						Paths.get(interface.name, s"${interface.name}.$extension"),
						Paths.get(interface.name, s"${interface.name}_entry.$extension")),
					s"$compiler $cflags -o $$@ -lrt $$^ -O2 " +
					"-D_XOPEN_SOURCE=600 -Wno-unused-result -Wall"))
		}
	}

	override def generateRunCommands() = {
		(if (parent) {
			List(idl.main)
		} else {
			idl.interfaces
		}).map(interface =>
			ExecDescription(Array(options.outputDirectory
				.resolve(Paths.get(interface.name, interface.name))
				.toString))
		)
	}

	def extension() = "c"

	def compiler() = "/usr/bin/gcc"

	def cflags() = "-std=c99"

	private def arrayDim(e: Expression) = s"[${e.value}]"

	private def formatPrimitive(t: PrimitiveType) = {
		t.name match {
			case "long" => "long long"
			case primitive: String => primitive
		}
	}

	private def formatType(t: Type) = {
		t match {
			case arrayType: ArrayType =>
				s"${formatPrimitive(arrayType.primitive)}(*)" +
					arrayType.lengths.tail.map(arrayDim).mkString
			case primitiveType: PrimitiveType =>
				s"${formatPrimitive(primitiveType)}"
		}
	}

	private def formatParam(param: Parameter) = {
		param.paramType match {
			case arrayType: ArrayType =>
				s"${formatPrimitive(arrayType.primitive)} ${param.name}[]" +
					arrayType.lengths.tail.map(arrayDim).mkString
			case primitiveType: PrimitiveType =>
				s"${formatPrimitive(primitiveType)} ${param.name}"
		}
	}

	private def fieldLength(fieldType: Type) = {
		fieldType match {
			case primitiveType: PrimitiveType =>
				s"sizeof(${primitiveType.name})"
			case arrayType: ArrayType =>
				s"sizeof(${arrayType.primitive.name}) * " +
					arrayType.lengths.map(_.value).mkString(" * ")
		}
	}

	private def declareFunction(function: Function) = {
		s"${formatPrimitive(function.returnType)} ${function.name}(" +
			function.params.map(formatParam).mkString(", ") + ")"
	}

	private def declareVar(param: Parameter) = {
		param.paramType match {
			case array: ArrayType =>
				s"${formatPrimitive(array.primitive)} (*${param.name})" +
					array.lengths.tail.map(arrayDim).mkString
			case primitive: PrimitiveType =>
				s"${formatPrimitive(primitive)} ${param.name}"
		}
	}

	private def generateHeader(interface: Interface) = {
		val builder = new StringBuilder
		builder ++= "/* Auto-generated by libinteractive */\n\n"
		interface.functions.map(declareFunction(_) + ";\n").foreach(builder ++= _)
		idl.main.functions.map(declareFunction(_) + ";\n").foreach(builder ++= _)
		OutputFile(
			Paths.get(interface.name, s"${options.moduleName}.h"),
			builder.mkString)
	}

	private def generate(interface: Interface) = {
		val builder = new StringBuilder
		builder ++= s"""/* Auto-generated by libinteractive */
#include "${options.moduleName}.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

static int __in = -1, __out = -1;

${generateMessageLoop(List((idl.main, interface, "__out")), "__in")}

int main(int argc, char* argv[]) {
	int retval = 0;

	${if (options.verbose) {
		"\tfprintf(stderr, \"\\t[" + interface.name + "] opening `" + pipeFilename(interface) + "'\\n\");\n"
	} else ""}
	if ((__in = open("${pipeFilename(interface)}", O_RDONLY)) == -1) {
		perror("open");
		retval = 1;
		goto cleanup;
	}
	${if (options.verbose) {
		"\tfprintf(stderr, \"\\t[" + interface.name + "] opening `" + pipeFilename(idl.main) + "'\\n\");\n"
	} else ""}
	if ((__out = open("${pipeFilename(idl.main)}", O_WRONLY)) == -1) {
		perror("open");
		retval = 1;
		goto cleanup;
	}

	__message_loop(-1);

cleanup:
	${if (options.verbose) {
		"\tfprintf(stderr, \"\\t[" + interface.name + "] closing `" + pipeFilename(interface) + "'\\n\");\n"
	} else ""}
	if (__in != -1) {
		if (close(__in) == -1) {
			perror("close");
		}
	}
	${if (options.verbose) {
		"\tfprintf(stderr, \"\\t[" + interface.name + "] closing `" + pipeFilename(idl.main) + "'\\n\");\n"
	} else ""}
	if (__out != -1) {
		if (close(__out) == -1) {
			perror("close");
		}
	}

	return retval;
}
"""
		for (function <- idl.main.functions) {
			builder ++= generateShim(function, idl.main, interface, "__out", "__in", false)
		}
		OutputFile(
			Paths.get(interface.name, s"${interface.name}_entry.$extension"),
			builder.mkString)
	}

	private def generateMainHeader() = {
		val builder = new StringBuilder
		builder ++= "/* Auto-generated by libinteractive */\n\n"
		idl.allInterfaces.flatMap(interface => {
			interface.functions.map(declareFunction(_) + ";\n")
		}).foreach(builder ++= _)
		OutputFile(
			Paths.get(idl.main.name, s"${options.moduleName}.h"),
			builder.mkString)
	}

	private def generateMainFile() = {
		val openPipes = idl.interfaces.map(interface => {
			(if (options.verbose) {
				s"""\tfprintf(stderr, "\\t[${idl.main.name}] opening `${pipeFilename(interface)}'\\n");\n"""
			} else {
				""
			}) +
s"""\tif ((${pipeName(interface)} = open("${pipeFilename(interface)}", O_WRONLY)) == -1) {
		perror("open");
		exit(1);
	}\n"""}).mkString("\n") +
			(if (options.verbose) {
				s"""\tfprintf(stderr, "\\t[${idl.main.name}] opening `${pipeFilename(idl.main)}'\\n");\n"""
			} else {
				""
			}) +
s"""\tif ((${pipeName(idl.main)} = open("${pipeFilename(idl.main)}", O_RDONLY)) == -1) {
		perror("open");
		exit(1);
	}\n"""
		val closePipes = (idl.interfaces ++ List(idl.main)).map(interface => {
			(if (options.verbose) {
				s"""\tfprintf(stderr, "\\t[${idl.main.name}] closing `${pipeFilename(interface)}'\\n");\n"""
			} else {
				""
			}) +
s"""\tif (${pipeName(interface)} != -1) {
		if (close(${pipeName(interface)}) == -1) {
			perror("close");
		}
	}"""}).mkString("\n")
		val builder = new StringBuilder
		builder ++= s"""/* Auto-generated by libinteractive */
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include "${options.moduleName}.h"

#ifdef __cplusplus
extern "C" {
#endif

// declared in crt1.o
void _start();

void __entry();
static void __exit();
static long long __elapsed_time = 0;
static int ${idl.allInterfaces.map(pipeName).mkString(", ")};

#ifdef __cplusplus
}
#endif

void __entry() {
$openPipes

	// Register __exit to be called when main returns.
	atexit(__exit);
	// Perform regular libc startup
	_start();
}

void __exit() {
$closePipes
}

"""
		builder ++= generateMessageLoop(
			idl.interfaces.map{
				interface => (interface, idl.main, pipeName(interface))
			},
			pipeName(idl.main)
		)
		idl.interfaces.foreach(interface => {
			interface.functions.foreach(
				builder ++= generateShim(_, interface, idl.main, pipeName(interface),
					pipeName(idl.main), true)
			)
		})
		
		OutputFile(
			Paths.get(idl.main.name, s"${idl.main.name}_entry.$extension"),
			builder.mkString)
	}

	private def generateMessageLoop(interfaces: List[(Interface, Interface, String)], infd: String) = {
		val builder = new StringBuilder
		builder ++= s"""static void __message_loop(int current_function) {
	int msgid;
	while (read($infd, &msgid, sizeof(int)) == sizeof(int)) {
		if (msgid == current_function) return;
		switch (msgid) {\n"""
		for ((caller, callee, outfd) <- interfaces) {
			for (function <- callee.functions) {
				builder ++= f"\t\t\tcase 0x${functionIds((caller.name, callee.name, function.name))}%x: {\n"
				builder ++= s"\t\t\t\t// ${caller.name} -> ${callee.name}.${function.name}\n"
				if (options.verbose) {
					builder ++=
						s"""\t\t\t\tfprintf(stderr, "\\t[${callee.name}] calling ${function.name} begin\\n");\n"""
				}
				for (param <- function.params) {
					builder ++= (param.paramType match {
						case array: ArrayType => {
							s"\t\t\t\t${declareVar(param)} = (${formatType(array)})" +
							s"malloc(${fieldLength(array)});\n" +
							s"\t\t\t\tread($infd, ${param.name}, ${fieldLength(array)});\n"
						}
						case primitive: PrimitiveType => {
							s"\t\t\t\t${declareVar(param)};\n" +
							s"\t\t\t\tread($infd, &${param.name}, ${fieldLength(primitive)});\n"
						}
					})
				}
				builder ++= s"\t\t\t\tint cookie;\n"
				builder ++= s"\t\t\t\tread($infd, &cookie, sizeof(int));\n"
				builder ++= (if (function.returnType == PrimitiveType("void")) {
					"\t\t\t\t"
				} else {
					s"\t\t\t\t${formatType(function.returnType)} result = "
				})
				builder ++=
					s"""${function.name}(${function.params.map(_.name).mkString(", ")});\n"""
				builder ++= s"\t\t\t\twrite($outfd, &msgid, sizeof(int));\n"
				if (function.returnType != PrimitiveType("void")) {
					builder ++= s"\t\t\t\twrite($outfd, &result, sizeof(result));\n"
				}
				builder ++= s"\t\t\t\twrite($outfd, &cookie, sizeof(int));\n"
				for (param <- function.params) {
					param.paramType match {
						case array: ArrayType => {
							builder ++= s"\t\t\t\tfree(${param.name});\n"
						}
						case _ => {}
					}
				}
				if (options.verbose) {
					builder ++=
						s"""\t\t\t\tfprintf(stderr, "\\t[${callee.name}] calling ${function.name} end\\n");\n"""
				}
				builder ++= "\t\t\t\tbreak;\n"
				builder ++= "\t\t\t}\n"
			}
		}
		builder ++= """			default: {
				fprintf(stderr, "Unknown message id 0x%x\n", msgid);
				exit(1);
			}
		}
	}
	if (current_function != -1) {
		fprintf(stderr, "Confused about exiting\n");
		exit(1);
	}
}
"""
		builder
	}

	private def generateShim(function: Function, callee: Interface, caller: Interface,
			outfd: String, infd: String, generateTiming: Boolean) = {
		val builder = new StringBuilder
		builder ++= declareFunction(function)
		builder ++= " {\n"
		if (options.verbose) {
			builder ++=
				s"""\tfprintf(stderr, "\\t[${caller.name}] invoking ${function.name} begin\\n");\n"""
		}
		builder ++= "\tconst int msgid = "
		builder ++= f"0x${functionIds((caller.name, callee.name, function.name))}%x;\n"
		builder ++= s"\twrite($outfd, &msgid, sizeof(int));\n"
		function.params.foreach(param => {
			builder ++= (param.paramType match {
				case _: PrimitiveType =>
					s"\twrite($outfd, &${param.name}, ${fieldLength(param.paramType)});\n"
				case _: ArrayType =>
					s"\twrite($outfd, ${param.name}, ${fieldLength(param.paramType)});\n"
			})
		})
		if (generateTiming) {
			builder ++=
				"\tstruct timespec t0, t1;\n\tclock_gettime(CLOCK_MONOTONIC, &t0);\n"
		}
		builder ++= f"\tint cookie = 0x${rand.nextInt}%x;\n"
		builder ++= s"\twrite($outfd, &cookie, sizeof(cookie));\n"
		builder ++= "\t__message_loop(msgid);\n"
		if (function.returnType != PrimitiveType("void")) {
			builder ++= s"\t${formatType(function.returnType)} ans = 0;\n"
			builder ++= s"\tread($infd, &ans, sizeof(ans));\n"
		}
		builder ++= "\tint cookie_result = 0;\n"
		builder ++= s"\tread($infd, &cookie_result, sizeof(int));\n"
		if (generateTiming) {
			builder ++= "\tclock_gettime(CLOCK_MONOTONIC, &t1);\n"
			builder ++= "\t__elapsed_time += (t1.tv_sec * 1000000 + t1.tv_nsec / 1000) - " +
				"(t0.tv_sec * 1000000 + t0.tv_nsec / 1000);\n"
		}

		builder ++= "\tif (cookie != cookie_result) {\n"
		builder ++= "\t\tfprintf(stderr, \"invalid cookie\\n\");\n"
		builder ++= "\t\texit(1);\n"
		builder ++= "\t}\n"

		if (options.verbose) {
			builder ++=
				s"""\tfprintf(stderr, "\\t[${caller.name}] invoking ${function.name} end\\n");\n"""
		}

		if (function.returnType != PrimitiveType("void")) {
			builder ++= "\treturn ans;\n"
		}
		builder ++= "}\n"

		builder
	}
}

class Cpp(idl: IDL, options: Options, parent: Boolean) extends C(idl, options, parent) {
	override def extension() = "cpp"

	override def compiler() = "/usr/bin/g++"

	override def cflags() = "-std=c++11"
}

/* vim: set noexpandtab: */
